import numpy as np
import matplotlib.pyplot as plt
import scipy.stats as stats
from datetime import datetime
import requests
import pandas as pd
import math
import time
import re
from bs4 import BeautifulSoup
from kalshi_client.client import KalshiClient
from cryptography.hazmat.primitives import serialization
from cryptography.hazmat.backends import default_backend
from typing import List, Tuple, Optional
import uuid
import numpy as np
import os

# -------------------------------------------
        # Functions
# -------------------------------------------

def load_private_key_from_file(private_key_path: str):
    """Load a PEM private key from a file."""
    with open(private_key_path, "rb") as key_file:
        private_key = serialization.load_pem_private_key(
            key_file.read(),
            password=None,
            backend=default_backend()
        )
    return private_key

def get_rotten_tomatoes_data(url: str, headers: dict) -> Tuple[Optional[int], Optional[int]]:
    response = requests.get(url, headers=headers)
    soup = BeautifulSoup(response.content, "html.parser")

    tomatometer_element = soup.find("rt-text", {"slot": "criticsScore"})
    tomatometer_score_grab = int(tomatometer_element.text.strip("%")) if tomatometer_element else None
    
    review_element = soup.find("rt-link", {"slot": "criticsReviews"})
    review_count = int(review_element.text.strip().replace(" Reviews", "")) if review_element else None
    tomatometer_score =  round(100 * round((tomatometer_score_grab/100 * review_count), 0) / review_count, 3) #calculate precise tomatometer score

    return tomatometer_score, review_count

def plot_tomatometer_distributions(tomatometer_score: float, review_count: int, final_review_count: int, check_ranges=None):
    """
    Vectorized version using Beta-Binomial distribution for efficient simulation.
    """
    # Convert score to fraction and calculate initial Beta parameters
    tomatometer_fraction = tomatometer_score / 100.0
    alpha0 = (tomatometer_fraction * review_count) + 1
    beta0 = ((1 - tomatometer_fraction) * review_count) + 1

    # Plot current Beta distribution (same as before)
    # x = np.linspace(0, 1, 1000)
    # current_pdf = stats.beta.pdf(x, alpha0, beta0)
    # plt.figure(figsize=(8, 5))
    # plt.plot(x * 100, current_pdf, label=f"Current Beta({alpha0:.1f}, {beta0:.1f})", color='b')
    # plt.axvline(tomatometer_score, color='r', linestyle="--", label=f"Observed {tomatometer_score}%")
    # plt.xlabel("Tomatometer Score (%)")
    # plt.ylabel("Probability Density")
    # plt.title("Current True Tomatometer Probability Distribution")
    # plt.legend()
    # plt.grid(True)
    # plt.show()

    # Vectorized simulation using Beta-Binomial distribution
    num_simulations = 50000
    additional_reviews = final_review_count - review_count
    
    if additional_reviews <= 0:
        final_scores = np.full(num_simulations, tomatometer_score)
    else:
        # Generate simulated positive reviews in one vectorized operation
        simulated_positives = stats.betabinom.rvs(
            n=additional_reviews,
            a=alpha0,
            b=beta0,
            size=num_simulations
        )
        
        # Calculate final scores using vectorized operations
        total_positives = (alpha0 - 1) + simulated_positives  # alpha0-1 = current positive reviews
        final_scores = (total_positives / final_review_count) * 100

    # Remaining plotting and probability calculations 
    # plt.figure(figsize=(8, 5))
    # plt.hist(final_scores, bins=50, density=True, alpha=0.7, color='g', 
    #          label=f"Predicted at {final_review_count} Reviews")
    # plt.axvline(tomatometer_score, color='r', linestyle="--", label=f"Current {tomatometer_score}%")
    # plt.xlabel("Tomatometer Score (%)")
    # plt.ylabel("Probability Density")
    # plt.title(f"Predicted Tomatometer Distribution at {final_review_count} Reviews")
    # plt.legend()
    # plt.grid(True)
    # plt.show()

    if check_ranges:
        zero_ranges = []
        for lower, upper in check_ranges:
            prob_mass = np.mean((final_scores >= lower) & (final_scores < upper))
            zero_ranges.append(prob_mass)
        return zero_ranges

    # -------------------------------------------
    # 2. Stepwise simulation of additional reviews.
    # -------------------------------------------
    num_simulations = 50000
    final_scores = np.zeros(num_simulations)
    
    # Number of additional reviews to simulate
    additional_reviews = final_review_count - review_count

    # If no additional reviews are coming in, then the final score is exactly the observed score.
    if additional_reviews <= 0:
        final_scores.fill(tomatometer_score)
    else:
        # For each simulation, update the Beta parameters review by review.
        for i in range(num_simulations):
            # Start with the current parameters
            alpha_sim = alpha0
            beta_sim = beta0
            # Stepwise update: simulate one review at a time.
            for _ in range(additional_reviews):
                # The predictive probability of a positive review is the mean of the current Beta.
                p_positive = alpha_sim / (alpha_sim + beta_sim)
                # Sample one new review outcome from a Bernoulli trial.
                if np.random.rand() < p_positive:
                    alpha_sim += 1  # positive review observed
                else:
                    beta_sim += 1   # negative review observed
            # The final number of positive reviews (excluding the prior) is (alpha_sim - 1),
            # and total reviews is final_review_count.
            final_score_fraction = (alpha_sim - 1) / (final_review_count)
            final_scores[i] = final_score_fraction * 100  # convert to percentage

    # -------------------------------------------
    # 3. Plot the predicted final distribution.
    # -------------------------------------------
    plt.figure(figsize=(8, 5))
    plt.hist(final_scores, bins=50, density=True, alpha=0.7, color='g', 
             label=f"Predicted at {final_review_count} Reviews")
    plt.axvline(tomatometer_score, color='r', linestyle="--", label=f"Current {tomatometer_score}%")
    plt.xlabel("Tomatometer Score (%)")
    plt.ylabel("Probability Density")
    plt.title(f"Predicted Tomatometer Distribution at {final_review_count} Reviews")
    plt.legend()
    plt.grid(True)
    plt.show()

    # -------------------------------------------
    # 4. Compute probability mass within user-defined ranges.
    # -------------------------------------------
    if check_ranges:
        #print("Probability mass within defined tomatometer score ranges (final distribution):")
        zero_ranges = []
        for (lower, upper) in check_ranges:
            # Calculate fraction of simulations with final score in the range [lower, upper)
            prob_mass = float(np.mean((final_scores >= lower) & (final_scores < upper)))
            zero_ranges.append(prob_mass)
            #print(f"Between {lower}-{upper}%: {prob_mass * 100:.2f}%")
        return zero_ranges
    


# -------------------------------------------
        # Kalshi Key
# -------------------------------------------

key_id = os.environ.get("KALSHI_KEY_ID")
private_key_path = os.environ.get("KALSHI_PRIVATE_KEY_PATH")
if not key_id or not private_key_path:
    raise ValueError("Please set the KALSHI_KEY_ID and KALSHI_PRIVATE_KEY_PATH environment variables.")

kalshi_client = KalshiClient(key_id=key_id, private_key=load_private_key_from_file(private_key_path))

# -------------------------------------------
# Kelly Criterion Calculations
# -------------------------------------------

def calculate_kelly_fraction(model_prob: float, market_price: float) -> float:
    """
    Calculates Kelly fraction for binary outcomes.
    Returns 0 if no edge exists.
    """
    if market_price <= 0 or market_price >= 100:
        return 0.0
    
    market_prob = market_price / 100
    edge = model_prob - market_prob
    
    # Only trade if we have positive edge
    if edge <= 0:
        return 0.0
    
    # Calculate net decimal odds
    b = (100 - market_price) / market_price  # Net odds received
    
    # Kelly formula
    raw_kelly = (b * model_prob - (1 - model_prob)) / b
    print(f"Raw: {raw_kelly*100:.1f}% → Half: {raw_kelly*50:.1f}%")  # Debug line
    return max(0.0, min(0.05, raw_kelly * 0.5))

def get_position_size(kelly_fraction: float, balance: int, price: int) -> int:
    """Convert Kelly fraction to contract count"""
    if kelly_fraction <= 0 or price <= 0:
        return 0
    
    # Calculate position size in cents
    risk_amount = kelly_fraction * balance
    return max(1, int(risk_amount // price))

def should_close_position(row, model_prob):
    """
    Determines if we should close a position based on edge loss.
    For YES positions: Close if model_prob <= market_prob
    For NO positions: Close if (1 - model_prob) <= market_prob
    """
    if row['position'] == 0:
        return False
        
    if row['position'] > 0:  # YES position
        market_prob = row['yes ask'] / 100
        return model_prob <= market_prob
    else:  # NO position (negative position)
        market_prob = row['no ask'] / 100
        return (1 - model_prob) <= market_prob
    
def calculate_total_exposure(positions, current_prices):
    """
    Calculate the total value of all open positions.
    """
    total_exposure = 0
    for pos in positions:
        ticker = pos['ticker']
        side = pos['side']
        quantity = pos['quantity']
        current_price = current_prices.get(ticker, {}).get(side, 0)
        total_exposure += quantity * current_price
    return total_exposure

def enforce_portfolio_cap(balance, total_exposure, new_position_value):
    """
    Ensure total exposure + new position value <= 20% of portfolio.
    """
    max_exposure = 0.2 * balance
    available_capacity = max(0, max_exposure - total_exposure)
    return min(new_position_value, available_capacity)

# -------------------------------------------
# Main function 
# -------------------------------------------



# Sleep duration in seconds (60 seconds = 1 minute)
SLEEP_DURATION = 60  
HIGHEST_REVIEW_COUNT = 0
TRADE_MADE_FOR_CURRENT_REVIEW = False  # Track if we've traded for current review


while True:
    iteration_start = datetime.now()
    print(f"\n=== New iteration started at {iteration_start} ===")
    
    try:
        # -------------------------------------------
        # Data Collection & Processing (unchanged)
        # -------------------------------------------
        current_time = datetime.now()
        print(current_time)
        
        # -------------------------------------------
                # Rotten Tomatoes Info
        # -------------------------------------------
        url = f"https://www.rottentomatoes.com/m/the_monkey?nocache={int(time.time())}"
        headers = {
            "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/114.0.0.0 Safari/537.36"
        }
        tomatometer_score, review_count = get_rotten_tomatoes_data(url, headers)
        print(f"Tomatometer Score: {tomatometer_score}, Review Count: {review_count}")
        eventTicker ='KXRTTHEMONKEY'
        data = kalshi_client.get_event(event_ticker=eventTicker)

        df = pd.DataFrame(columns=["ticker", "threshold"])
        for market in data.get("markets", []):
            if "ticker" in market and market["ticker"].startswith(f"{eventTicker}-"):
                match = re.search(fr'{eventTicker}-(\d+)', market["ticker"])
                if match:
                    threshold_value = int(match.group(1)) + 0.5
                    if not df.empty:
                        df = pd.concat([df, pd.DataFrame([{ "ticker": market["ticker"], "threshold": threshold_value }])], ignore_index=True)
                    else:
                        df = pd.DataFrame([{ "ticker": market["ticker"], "threshold": threshold_value }])


        markets_df = df
# -------------------------------------------
        # Getting book odds

        balance = kalshi_client.get_balance()
        print(balance)
# -------------------------------------------        
        book_yes_odds_list = []
        book_no_odds_list = []
        book_yes_bids_list = []
        book_no_bids_list = []

        for _, row in markets_df.iterrows():
            marketTicker = row["ticker"]
            marketResponse = kalshi_client.get_market(marketTicker)
            
            if marketResponse and "market" in marketResponse:
                market_data = marketResponse["market"]
                book_yes_odds_list.append(market_data.get("yes_ask"))
                book_no_odds_list.append(market_data.get("no_ask"))
                book_yes_bids_list.append(market_data.get("yes_bid"))
                book_no_bids_list.append(market_data.get("no_bid"))

        complete_odds_df = markets_df.copy()
        complete_odds_df['yes ask'] = book_yes_odds_list
        complete_odds_df['yes bid'] = book_yes_bids_list

        complete_odds_df['no ask'] = book_no_odds_list
        complete_odds_df['no bid'] = book_no_bids_list

# -------------------------------------------
        # Get relevant markets
# -------------------------------------------
        def get_ranges():
            ranges = []
            for index, row in markets_df.iterrows():
                threshold = row['threshold']
                ranges.append((0,threshold))

            return ranges
        ranges_list = get_ranges()

# -------------------------------------------
        # Calculate Odds
# -------------------------------------------

        zero_ranges_list = plot_tomatometer_distributions(
            tomatometer_score=tomatometer_score,
            review_count=review_count,
            final_review_count = 150, #input final review count estimate
            check_ranges=ranges_list,
            
        )
        above_odds_list = []

        for i in zero_ranges_list: #adding calculated odds to dataframe for trading
            above_odds_list.append(round((1-i), 3)*100)

        complete_odds_df['above odds'] = above_odds_list

# -------------------------------------------
        # Add current open positions
# -------------------------------------------

        my_positions = kalshi_client.get_positions()
        filtered_positions = [
            {'ticker': position['ticker'], 'position': position['position']}
            for position in my_positions['market_positions']
            if position['position'] != 0
        ]


        my_positions_df = pd.DataFrame(filtered_positions)

        final_df = complete_odds_df.merge(my_positions_df, on="ticker", how="left").fillna({'position': 0}) 
       
        print(final_df)

# -------------------------------------------
# Modified Trading Section
# -------------------------------------------
 # Check for new reviews
    
        new_review_detected = False
        if review_count > HIGHEST_REVIEW_COUNT:
            print(f"🚨 New highest review count: {HIGHEST_REVIEW_COUNT} → {review_count}")
            HIGHEST_REVIEW_COUNT = review_count
            TRADE_MADE_FOR_CURRENT_REVIEW = False  # Reset trade flag
            new_review_detected = True
            print("Processing new review...")

            # Get account balance in cents
            balance_response = kalshi_client.get_balance()
            current_balance = balance_response['balance']  # In cents

            for _, row in final_df.iterrows():
                ticker = row['ticker']
                current_position = row['position']
                
                # Calculate Yes side Kelly
                yes_kelly = calculate_kelly_fraction(
                    model_prob=row['above odds']/100,
                    market_price=row['yes ask']
                )
                yes_position = get_position_size(
                    yes_kelly, current_balance, row['yes ask']
                )
                
                # Calculate No side Kelly
                no_kelly = calculate_kelly_fraction(
                    model_prob=(100 - row['above odds'])/100,
                    market_price=row['no ask']
                )
                no_position = get_position_size(
                    no_kelly, current_balance, row['no ask']
                )

                # Execute trades only if we have positive edge
                if yes_position > 0:
                    position_value = current_position * row['yes ask']
                    if position_value < 5000:
                        orderUuid = str(uuid.uuid4())
                            # kalshi_client.create_order(
                            #     client_order_id=orderUuid,
                            #     side="yes",
                            #     action="buy",
                            #     count=yes_position,
                            #     type="market",
                            #     ticker=ticker,
                            # )

                        print(f"Bought {yes_position} YES @ {row['yes ask']}c (Kelly: {yes_kelly*100:.1f}%)")
                    

                if no_position > 0:
                    position_value = current_position * row['yes ask']
                    if position_value < 5000:
                        orderUuid = str(uuid.uuid4())
                        try:
                            # kalshi_client.create_order(
                            #     client_order_id=orderUuid,
                            #     side="no",
                            #     action="buy",
                            #     count=no_position,
                            #     type="market",
                            #     ticker=ticker,
                            # )
                            print(f"Bought {no_position} NO @ {row['no ask']}c (Kelly: {no_kelly*100:.1f}%)")

                        except Exception as e:
                            print(f"Error occurred: {e}")
        
        if review_count == HIGHEST_REVIEW_COUNT:
            print(f'⏳ No new reviews - maintaining current positions')

        if review_count < HIGHEST_REVIEW_COUNT:
            print(f'Review(s) taken off RT site - maintaining current positions')
            
            print("\nChecking position edges:")
            for _, row in final_df.iterrows():
                if row['position'] == 0:
                    continue
                
                model_prob = row['above odds'] / 100
                if should_close_position(row, model_prob):
                    print(f"Closing position in {row['ticker']} (Edge lost)")
                    try:
                        # Determine side based on position direction
                        side = "yes" if row['position'] > 0 else "no"
                        
                        orderUuid = str(uuid.uuid4())
                        # kalshi_client.create_order(
                        #     client_order_id=orderUuid,
                        #     side=side,
                        #     action="sell",
                        #     count=abs(row['position']),
                        #     type="market",
                        #     ticker=row['ticker'],
                        # )
                        print(f"Closed {abs(row['position'])} {side.upper()} @ {row[f'{side} ask']}c")
                    except Exception as e:
                        print(f"Error closing position: {e}")
                
        print(f'sleeping for 60 seconds')
        time.sleep(60)

            
        
    except Exception as e:
        print(f'ERROR: {KeyError}')
      
        
